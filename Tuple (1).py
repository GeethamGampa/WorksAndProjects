# -*- coding: utf-8 -*-
"""Work_J.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p9t7h0TJZR6ZCCIq-nLv5wXbUPVHjtwf

# **TUPLE**

*It is an ordered, immutable collection of elements.*

- *Ordered: The items have a fixed order.*

- *Immutable: Once created, you cannot change (add, remove, or modify) the items - crud operations*
"""

my_tuple = (1,2,3)
print(my_tuple[1])

"""# **Why do we use Tuples?**

- *They are faster than lists.*

- *They protect data from being changed accidentally.*

- *Can be used as keys in dictionaries if they contain only immutable items.*

# **Tuple inbuilt functions**

- *len()- Returns the number of elements*
- *max()- Returns the maximum value*
- *min()- Returns the minimum value*
- *sum()- Returns the sum of elements*
- *tuple()- Converts an iterable to a tuple*
- *count(x)- Returns number of times x appears*
- *index(x)- Returns first index of x*

# **Examples**

***To access the elements***
"""

t = ("apple", "mango", "strawberry")
print(t[0])
print(t[-2])

"""***To count the number of occurrences***"""

nums = (1, 2, 2, 3, 4, 2, 4, 5, 4, 4 )
print(nums.count(4))

"""***To find index***"""

names = ("Christy", "Sara", "Charlie")
print(names.index("Sara"))

"""***Tuple with loop***"""

fruits = ("apple", "mango", "cherry")
for fruit in fruits:
    print(fruit)

"""***Unpacking tuples***"""

person = ("Sri", 25, "USA")
name, age, country = person
print("Name : ", name)
print("Age : ", age)
print("Country : ", country)

"""***Sum and Average***"""

marks = (70, 85, 90, 60)
total = sum(marks)

# Average = total / number of items
average = total / len(marks)

print("Total Marks:", total)
print("Average Marks:", average)

"""***Given the participants' score sheet for your University Sports Day, you are required to find the runner-up score. You are given n scores. Store them in a list and find the score of the runner-up.***

***Steps Breakdown***

> *We need to take all the scores from the user and store them in a list.*

> *Remove repeated scores using a set.*

> *Sort the list in descending order (highest to lowest).*

> *Pick the second number in the sorted list — that's the runner-up score.*
"""

if __name__ == '__main__':
    n = int(input())
    arr = list(map(int, input().split()))

    # Remove duplicates by converting to a set
    scores = list(set(arr))

    # Sort in descending order
    scores.sort(reverse=True)

    # Print the second highest (runner-up)
    print(scores[1])

"""***Given an integer, n, and  n space-separated integers as input, create a tuple, t, of those n integers. Then compute and print the result of hash(t)***

**Breakdown**

*To solve this, we need to create a tuple from the given integers, and then compute the hash value of that tuple using Python's built-in hash() function.*
"""

if __name__ == '__main__':
    n = int(input())
    integer_list = map(int, input().split())

     # Convert the map object to a tuple
    int_tuple = tuple(integer_list)

    # Print the hash value of the tuple
    print(hash(int_tuple))

"""# **SUDOKU**"""

#    0 1 2 3
#0 #1 0 0 4
#1 #0 0 3 0
#2 #0 3 0 0
#3 #4 0 0 2

#       row column
#        ^  ^
#        |  |
# sudoko[0][0]=1, sudoko[0][1]=0, sudoko[0][2]=0, sudoko[0][3]=4
# sudoko[1][0]=0, sudoko[1][1]=0, sudoko[1][2]=3, sudoko[1][3]=0
# sudoko[2][0]=0, sudoko[2][1]=3, sudoko[2][2]=0, sudoko[2][3]=0
# sudoko[3][0]=4, sudoko[3][1]=0, sudoko[3][2]=0, sudoko[3][3]=2

sudoko = [[1,0,0,4],
          [0,0,3,0],
          [0,3,0,0],
          [4,0,0,2]]

def is_valid(board, row, col, num):
  for i in range(0,4):
    if board[row][i]==num or board[i][col]==num:
      return False
  start_row, start_col = 2 *(row//2), 2*(col//2)
  for i in range(start_row, start_row+2):
    for j in range(start_col, start_col+2):
      if board[i][j]==num:
         return False

  return True

def solve_sudoko(board):
  for row in range(0,4):
    for col in range(0,4):
      if board[row][col]==0:
        for num in range(1,5): #need 4 numbers(1,2,3,4)
          if is_valid(board, row, col, num):
            board[row][col]=num

            if solve_sudoko(board): #backtracking
             return True
          else:
            board[row][col]=0
        return False
  return True

# def print_board(board):
#   for row in board:
#     print(" ".join(str(num) for num in row))

def print_board(board):
  for row in board:
    print(row)

if solve_sudoko(sudoko)==True:
  print("Solution")
  print_board(sudoko)
else:
  print("No solution")

def is_valid(board, row, col, num):
    # Check if the number is not repeated in the row
    for i in range(4):
        if board[row][i] == num:
            return False

    # Check if the number is not repeated in the column
    for i in range(4):
        if board[i][col] == num:
            return False

    # Check if the number is not repeated in the 2x2 subgrid
    start_row, start_col = 2 * (row // 2), 2 * (col // 2)
    for i in range(start_row, start_row + 2):
        for j in range(start_col, start_col + 2):
            if board[i][j] == num:
                return False

    return True

def solve_sudoku(board):
    for row in range(4):
        for col in range(4):
            if board[row][col] == 0:  # Find an empty cell
                for num in range(1, 5):  # Try numbers 1 to 4
                    if is_valid(board, row, col, num):
                        board[row][col] = num
                        if solve_sudoku(board):
                            return True
                        board[row][col] = 0  # Backtrack
                return False
    return True

def print_board(board):
    for row in board:
        print(row)


# Given Sudoku puzzle
sudoku = [
    [1, 0, 0, 4],
    [0, 0, 1, 0],
    [3, 0, 0, 0],
    [4, 0, 0, 1]
]

if solve_sudoku(sudoku):
    print("Solution:")
    print_board(sudoku)
else:
    print("No solution")

import time
start_time = time.time()
def is_valid(board, row, col, num):

   # Check if placing 'num' in board[row][col] is valid.

    # Check if 'num' is already in the same row
    for i in range(4):
        if board[row][i] == num:
            return False  # 'num' found in the row, not valid

    # Check if 'num' is already in the same column
    for i in range(4):
        if board[i][col] == num:
            return False  # 'num' found in the column, not valid

    # Determine the starting row and column of the 2x2 subgrid
    start_row = (row // 2) * 2
    start_col = (col // 2) * 2

    # Check if 'num' is already in the 2x2 subgrid
    for i in range(start_row, start_row + 2):
        for j in range(start_col, start_col + 2):
            if board[i][j] == num:
                return False  # 'num' found in the subgrid, not valid

    return True  # 'num' is valid in this position

def solve_sudoku(board):

    # Solve the Sudoku puzzle using backtracking.


    # Loop through each cell in the 4x4 board
    # for row in range(4):
    #     for col in range(4):
 def solve_sudoko(board, row = 0, col = 0):
    if row == 4:
        return True
    if col == 4:
        return solve_sudoko(board, row+1, 0)

    if board[row][col] != 0:
        return solve_sudoko(board, row, col+1)

    for num in range(1,5):
        if is_valid(board, row, col, num) == True:
            board[row][col] = num
            if solve_sudoko(board, row, col+1):
                        return True
            board[row][col] = 0
    return False

# start_time = time.time()
def print_board(board):

    # Print the Sudoku board in a readable format.

    for row in board:
        print(*row)
    # for row in board:
    #     print(" ".join(str(num) for num in row))

# Sample Sudoku puzzle
sudoku = [
    [1, 0, 0, 4],
    [0, 0, 1, 0],
    [3, 0, 0, 0],
    [4, 0, 0, 1]
]

# Attempt to solve the Sudoku puzzle
if solve_sudoku(sudoku):
    print("Solution:")
    print_board(sudoku)  # Print the solved board
else:
    print("No solution")  # No solution exists for this puzzle
end_time = time.time()
print(end_time - start_time)

import time
start_time = time.time()
i = 0
while i < 10:
    print(i)
    i+=1
end_time = time.time()
print(end_time - start_time)

start_time = time.time()
for i in range(0,10):
    print(i)
end_time = time.time()
print(end_time - start_time)

"""[1, 0, 0],

[0, 2, 0],

[0, 0, 3]

> *Try a number in an empty cell.*

> *If it's valid, move to the next cell.*

> *If no number works, go back and try another number in the previous cell.*

> *Repeat until the full matrix is solved.*

"""

#   0  1  2
   #0 [1, 0, 0],
   #1 [0, 2, 0],
   #2 [0, 0, 3]

# Initial 3x3 Sudoku board where 0 -> an empty cell
board = [
    [1, 0, 0],
    [0, 2, 0],
    [0, 0, 3]
]

# Function to check if placing 'num' at board[row][col] is valid
def is_valid(board, row, col, num):

    # The loop goes through the columns and rows to check if the number
    # we trying to place already exists in the current row or column.
    for i in range(3):

        # To check whether the number I want to place already in the same row or column?
        # For eg: i = 0:
        # board[0][0] == 2? → 1 == 2 -> No - can be placed
        # board[0][0] == 2? → 1 == 2 -> No - can be placed

        #i = 1:
        # board[0][1] == 2? → 0 == 2 -> No - can be placed
        # board[1][0] == 2? → 0 == 2 -> No - can be placed

        # i = 2:
        # board[0][2] == 2? → 0 == 2 -> No - can be placed
        # board[2][0] == 2? → 0 == 2 -> No - can be placed

        # we’re not checking whether the cell is empty
        # we're checking whether the number we're trying to insert (2) is
        # already present in that row or column

        if board[row][i] == num or board[i][col] == num:
            # If the number we're trying to place is already present
            # in either the row or the column, the function returns False
            # will try a different number
            return False  # Not valid if found

    # does not actually place the number; it simply indicates that the number can be placed
    return True  # Valid if not found in row or column


# Recursive function that solves the board using backtracking
def solve_sudoku(board):
    for row in range(3):             # Go through all rows
        for col in range(3):         # Go through all columns
            if board[row][col] == 0:  # If the cell is empty
                for num in range(1, 4):  # Try numbers 1 to 3

                    if is_valid(board, row, col, num):  # Check if number is valid
                        board[row][col] = num  # Place the number

                        if solve_sudoku(board):  # Recursively solve the rest of the board
                            return True  # If it leads to a solution, return True

                        # if the current empty cell can't be filled with any valid number (1, 2, or 3), then:
                        # go back to the previous cell we filled, and try a different number there.
                        # To do that, we reset that previous cell to 0,

                        board[row][col] = 0  # Backtrack if it doesn't lead to solution

                return False  # No number is valid for this cell, trigger backtracking
    return True  # All cells filled successfully

# Function to print the board
def print_board(board):
    for row in board:
        print(*row)  # Unpacks the row and prints it

# Try to solve the board and print the solution
if solve_sudoku(board):
    print("Solution:")
    print_board(board)
else:
    print("No solution")

import time

# Initial 3x3 Sudoku board where 0 -> an empty cell
board = [
    [1, 0, 0],
    [0, 2, 0],
    [0, 0, 3]
]

# Function to check if placing 'num' at board[row][col] is valid
def is_valid(board, row, col, num):
    # Loop through rows and columns to check if 'num' is already present

    # Time complexity like O(3) tells how many times the loop runs
    for i in range(3):  # Checking 3 cells in row and column (O(3))
        if board[row][i] == num or board[i][col] == num:
            return False  # Not valid if found in row or column
    return True  # Valid if 'num' is not found

# Recursive function to solve the Sudoku board using backtracking
def solve_sudoku(board):
    for row in range(3):  # O(3) - iterating through rows
        for col in range(3):  # O(3) - iterating through columns
            if board[row][col] == 0:  # Check if the cell is empty
                for num in range(1, 4):  # Try numbers 1 to 3 (O(3))
                    if is_valid(board, row, col, num):  # O(3) - check validity
                        board[row][col] = num  # Place number
                        if solve_sudoku(board):  # Recursively solve the rest (recursive call)
                            return True  # If solution is found, return True
                        board[row][col] = 0  # Backtrack if no solution found
                return False  # No valid number found, trigger backtracking
    return True  # All cells filled successfully

# Function to print the board
def print_board(board):
    for row in board:
        print(*row)  # Print each row

# Measure time taken to solve the puzzle
start_time = time.time()

# solve the board and print the solution
if solve_sudoku(board):
    print("Solution:")
    print_board(board)
else:
    print("No solution")

# Measure the end time and calculate the execution time
end_time = time.time()
print("Time taken to solve the Sudoku:", end_time - start_time)

import time

# Sample 9x9 Sudoku board (0 means empty cell)
board = [
  [0, 3, 0, 0, 0, 8, 0, 1, 0],
  [6, 0, 2, 0, 0, 0, 3, 0, 8],
  [0, 9, 0, 0, 4, 0, 0, 6, 0],
  [0, 0, 9, 0, 6, 0, 4, 0, 3],
  [0, 2, 6, 8, 0, 0, 0, 9, 1],
  [0, 0, 3, 0, 0, 4, 8, 0, 0],
  [0, 6, 0, 0, 3, 0, 0, 8, 0],
  [2, 0, 7, 0, 0, 0, 6, 3, 0],
  [0, 4, 0, 0, 8, 0, 0, 0, 9],
]

# Function to check if placing 'num' at board[row][col] is valid
def is_valid(board, row, col, num):

    # Check if 'num' is already in the current row or column
    for i in range(9):
        if board[row][i] == num or board[i][col] == num:
            return False  # Not valid if number already exists in row or column

    # In a 9x9 Sudoku, the grid is divided into 3x3 blocks
    # So, we get the block's starting row and column like this:
    start_row = (row // 3) * 3
    start_col = (col // 3) * 3

    # Check all cells in the 3x3 subgrid
    # For eg:  we're checking cell at row = 4, col = 5
    # start_row = (4 // 3) * 3 = 1 * 3 = 3
    # start_col = (5 // 3) * 3 = 1 * 3 = 3
    # This means we are in the subgrid that starts at cell (3, 3)

    # for i in range(3, 6):  # rows 3, 4, 5
    # for j in range(3, 6):  # cols 3, 4, 5

    # (3,3) (3,4) (3,5)
    # (4,3) (4,4) (4,5)
    # (5,3) (5,4) (5,5)

    # any of these cells already has the same num, it returns False


    for i in range(start_row, start_row + 3):
        for j in range(start_col, start_col + 3):
            if board[i][j] == num:
                return False  # Not valid if number already exists in the block

    return True  # All checks passed, it's valid

# Function to solve the Sudoku using backtracking
def solve_sudoku(board):
    for row in range(9):
        for col in range(9):
            if board[row][col] == 0:  # Look for an empty cell
                for num in range(1, 10):  # Try numbers 1 to 9
                    if is_valid(board, row, col, num):  # Check if it's safe to place the number
                        board[row][col] = num  # Place number
                        if solve_sudoku(board):  # Recursive call to solve the rest
                            return True
                        board[row][col] = 0  # Backtrack if no solution
                return False  # No valid number found, trigger backtracking
    return True  # Puzzle solved successfully

# Function to print the Sudoku board
def print_board(board):
    for row in board:
        print(*row)  # Print each row

# Measure time taken to solve the puzzle
start_time = time.time()

# Solve and print solution
if solve_sudoku(board):
    print("Solution:")
    print_board(board)
else:
    print("No solution")

# Show time taken to solve
end_time = time.time()
print("Time taken to solve the Sudoku:", end_time - start_time)

"""# ***With Recursion***"""

import time
start_time = time.time()

def is_valid(board, row, col, num):
    for i in range(4):
        if board[row][i] == num or board[i][col] == num:
            return False

    start_row = (row // 2) * 2
    start_col = (col // 2) * 2
    for i in range(start_row, start_row + 2):
        for j in range(start_col, start_col + 2):
            if board[i][j] == num:
                return False
    return True

def solve_sudoku(board, row=0, col=0):
    if row == 4:
        return True
    if col == 4:
        return solve_sudoku(board, row + 1, 0)

    if board[row][col] != 0:
        return solve_sudoku(board, row, col + 1)

    for num in range(1, 5):
        if is_valid(board, row, col, num):
            board[row][col] = num
            if solve_sudoku(board, row, col + 1):
                return True
            board[row][col] = 0 #backtrack
    return False

def print_board(board):
    for row in board:
        print(*row)

sudoku = [
    [0, 0, 0, 3],
    [0, 4, 0, 0],
    [0, 0, 3, 2],
    [0, 0, 0, 0]
]

if solve_sudoku(sudoku):
    print("Solution:")
    print_board(sudoku)
else:
    print("No solution")

end_time = time.time()
print("Time:", end_time - start_time)

"""# ***Without Recursion***"""

import time
start_time = time.time()

def is_valid(board, row, col, num):
    # Check if the number is not repeated in the row
    for i in range(4):
        if board[row][i] == num:
            return False

    # Check if the number is not repeated in the column
    for i in range(4):
        if board[i][col] == num:
            return False

    # Check if the number is not repeated in the 2x2 subgrid
    start_row, start_col = 2 * (row // 2), 2 * (col // 2)
    for i in range(start_row, start_row + 2):
        for j in range(start_col, start_col + 2):
            if board[i][j] == num:
                return False

    return True

def solve_sudoku(board):
    for row in range(4):
        for col in range(4):
            if board[row][col] == 0:  # Find an empty cell
                for num in range(1, 5):  # Try numbers 1 to 4
                    if is_valid(board, row, col, num):
                        board[row][col] = num
                        if solve_sudoku(board):
                            return True
                        board[row][col] = 0  # Backtrack
                return False
    return True

def print_board(board):
    for row in board:
        print(*row)


# Given Sudoku puzzle
sudoku = [
    [1, 0, 0, 4],
    [0, 0, 1, 0],
    [3, 0, 0, 0],
    [4, 0, 0, 1]
]

if solve_sudoku(sudoku):
    print("Solution:")
    print_board(sudoku)
else:
    print("No solution")

end_time = time.time()
print("Time:", end_time - start_time)