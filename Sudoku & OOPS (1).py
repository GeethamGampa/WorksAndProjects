# -*- coding: utf-8 -*-
"""Work_a.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PfVPktKEdIpH64TqpCbXnOaXG4ZtL5Qo

# ***9x9 Sudoku***

### ***To calculate space complexity :***

***tracemalloc.start()***  *is a function from the tracemalloc module in Python, which is used for tracking memory allocations*
"""

import time
import tracemalloc

start_time = time.time()
tracemalloc.start()

# is_valid checks if placing a number is allowed or not
def is_valid(board, row, col, num):
    # Check if the number is not repeated in the row
    # loops through all columns in the row
    for i in range(9):
        if board[row][i] == num:
            return False # if any cell has same num, return false

    # Check if the number is not repeated in the column
    # loops through all rows in the column
    for i in range(9):
        if board[i][col] == num:
            return False # if any cell has same num, return false

    # Check if the number is not repeated in the 3x3 subgrid
    start_row = 3 * (row // 3)
    start_col = 3 * (col // 3)
    for i in range(start_row, start_row + 3):
        for j in range(start_col, start_col + 3):
            if board[i][j] == num: # if the number already exists then return false
                return False

    return True

def solve_sudoku(board):
    for row in range(9):
        for col in range(9):
            if board[row][col] == 0:  # Find an empty cell
                for num in range(1, 10):  # Try numbers 1 to 9

                    # before placing number, we check whether it is safe to place that num or not
                    if is_valid(board, row, col, num):
                        board[row][col] = num   # if valid, place that number
                        if solve_sudoku(board): # calling itself - recursion and tries to solve rest of the sudoku
                            return True
                        board[row][col] = 0  # if puzzle not solved - Backtrack
                return False # if no num works
    return True

def print_board(board):
    for row in board:
        print(*row)


# Given Sudoku puzzle
sudoku = [
  [0, 3, 0, 0, 0, 8, 0, 1, 0],
  [6, 0, 2, 0, 0, 0, 3, 0, 8],
  [0, 9, 0, 0, 4, 0, 0, 6, 0],
  [0, 0, 9, 0, 6, 0, 4, 0, 3],
  [0, 2, 6, 8, 0, 0, 0, 9, 1],
  [0, 0, 3, 0, 0, 4, 8, 0, 0],
  [0, 6, 0, 0, 3, 0, 0, 8, 0],
  [2, 0, 7, 0, 0, 0, 6, 3, 0],
  [0, 4, 0, 0, 8, 0, 0, 0, 9],
]

if solve_sudoku(sudoku):
    print("Solution:")
    print_board(sudoku)
else:
    print("No solution")

end_time = time.time()

# tracemalloc.get_traced_memory() gives 2 values
# Current memory used by your program (in bytes)
# Peak memory â€” the most memory used at any moment during the run
# _ ignores the value
total_memory, _ = tracemalloc.get_traced_memory()
tracemalloc.stop()

print(f"Time taken: {end_time - start_time:.2f} seconds") # taking upto 2 decimals
print(f"Total memory used: {total_memory / 1024:.2f} KB") # memory is in bytes, so changing them to kb --> dividing by 1024bytes = 1kb
print(f"Total memory used: {total_memory / (1024 * 1024):.2f} MB") # 1mb = 1024kb

"""#ðŸ”¹***Single Inheritance***

##### ***Create a class Person with attributes name and age. Inherit a class Employee that adds salary. Write a method to display all attributes.***
"""

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Employee(Person):
    def __init__(self, name, age, salary):
        super().__init__(name, age)
        self.salary = salary

        # method to display all attributes
    def display_attributes(self):
        print(f"Name: {self.name}")
        print(f"Age: {self.age}")
        print(f"Salary: {self.salary}")

e1 = Employee("Casey", 35, 60000)
e1.display_attributes()

"""##### ***Define a class Animal with a method speak(). Inherit it in class Dog and override the speak() method to print "Bark".***"""

class Animal:
    def speak(self):
        print("The animal speaks")

class Dog(Animal):
    def speak(self):
        print("Bark")

d1 = Dog()
d1.speak()

"""##### ***Make a class Vehicle with a method info() that prints "This is a vehicle". Create a class Car that inherits Vehicle and adds a method brand() which prints the car's brand.***


"""

class Vehicle:
    def info(self):
        print("This is a vehicle")

class Car(Vehicle):
    def brand(self):
        print("The car's brand is Audi")

c1 = Car()
# car.info()
c1.brand()

"""##### ***Build a class Shape with a method area() that returns 0. Inherit a class Square that overrides area() to return area of a square (given side).***

"""

class Shape:
    def area(self):
        return 0

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side ** 2 # Area=side^2
s1 = Square(3)

print(f"Area of the square: {s1.area()}")

"""##### ***Write a class Parent with a private variable and a getter method. Inherit a class Child and access the private variable via the getter.***"""

class Parent:
    def __init__(self, name):
        self.__name = name  # Private variable

    def get_name(self):
        return self.__name  # Getter method to access the private variable

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)  # Call Parent class constructor
        self.age = age

    def display(self):
        print(f"Name: {self.get_name()}, Age: {self.age}")


c1 = Child("Charli", 10)
# Access the private variable of Parent using the getter method
c1.display()

"""# ðŸ”¸***Multiple Inheritance***

##### ***Create two classes Writer and Editor, each with a method role(). Inherit a class Author from both and override role() to describe an author's combined role.***
"""

# Parent Class 1
class Writer:
    def role(self):
        print("The writer creates content.")

# Parent Class 2
class Editor:
    def role(self):
        print("The editor edits content.")

# Child Class
class Author(Writer, Editor):
    def role(self):
        print("The author both creates and edits content.")

a1= Author()
a1.role()

"""##### ***Define a class MathTeacher with a method teach(), and another class BasketballCoach with train(). Make a SchoolStaff class that inherits both and uses both methods.***

"""

# Parent Class 1
class MathTeacher:
    def teach(self):
        print("Teach Mathematics to the students.")

# Parent Class 2
class BasketballCoach:
    def train(self):
        print("Train students for basketball.")

# Child Class
class SchoolStaff(MathTeacher, BasketballCoach):
    # No new method is required because it inherits both teach() and train()
    pass

s1 = SchoolStaff()
s1.teach()
s1.train()

"""##### ***Create classes A and B with a method say() that prints different messages. Inherit class C(A, B) and call say(). What gets printed?***"""

class A:
    def say(self):
        print("Hi from A")

class B:
    def say(self):
        print("Hey from B")

class C(A, B):
    pass

# class C(B, A):
#     pass

c1 = C()
c1.say()

"""##### ***Simulate a class Person and class Athlete. Make a subclass StudentAthlete that inherits from both, and demonstrate accessing attributes/methods from both base classes.***

"""

# Parent class 1
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def intro(self):
        print(f"My name is {self.name} and I am {self.age} years old.")

# Parent class 2
class Athlete:
    def __init__(self, sport):
        self.sport = sport

    def play(self):
        print(f"I play {self.sport}.")

# Child class - inherits from both Person and Athlete
class StudentAthlete(Person, Athlete):
    def __init__(self, name, age, sport, team):
        Person.__init__(self, name, age)
        Athlete.__init__(self, sport)
        self.team = team

    def train(self):
        print(f"I train with {self.team} team.")


s1 = StudentAthlete("Max", 25, "Basketball", "Lions")

s1.intro()
s1.play()
s1.train()

"""# ðŸ”¹***Multilevel Inheritance***

##### ***Create a class Grandparent with a method history(). Inherit Parent from it and add legacy(). Inherit Child from Parent and add future(). Call all three methods from a Child object***
"""

class Grandparent:
    def history(self):
        print("Grandparent: Our family have a great history.")

class Parent(Grandparent):
    def legacy(self):
        print("Parent: My son carry our family's legacy.")

class Child(Parent):
    def future(self):
        print("Child: I will shape my future.")

# Create an object of Child
child_obj= Child()

# Call all three methods
child_obj.history()
child_obj.legacy()
child_obj.future()

"""##### ***Make a base class Device with a method specs(). Inherit Phone from Device, and Smartphone from Phone. Override specs() at each level and see which one gets called.***

"""

class Device:
    def specs(self):
        print("Device specifications.")

class Phone(Device):
    def specs(self):
        print("Phone specifications.")

class Smartphone(Phone):
    def specs(self):
        print("Smartphone specifications.")

# Create objects
d1 = Device()
p1 = Phone()
s1 = Smartphone()

# Call specs() method from each object
d1.specs()
p1.specs()
s1.specs()

"""##### ***Design a multilevel class structure: Organism -> Animal -> Human, each with a method info(). Override the method at each level and call info() from a Human object.***"""

class Organism:
    def info(self):
        print("Living organism.")

class Animal(Organism):
    def info(self):
        print("I am an animal")

class Human(Animal):
    def info(self):
        print("I am a human")

# Create an object
h1 = Human()
h1.info()

"""##### ***Implement a multilevel inheritance where the base class University has details like name and location, College inherits it with department info, and Student inherits College with personal details. Print complete student info.***

"""

class University:
    def __init__(self, name, location):
        self.name = name
        self.location = location

    def university_info(self):
        print(f"University: {self.name}")
        print(f"Location: {self.location}")

class College(University):
    def __init__(self, name, location, department):
        super().__init__(name, location)
        self.department = department

    def college_info(self):
        print(f"Department: {self.department}")

class Student(College):
    def __init__(self, name, location, department, student_name, age, roll_call):
        super().__init__(name, location, department)
        self.student_name = student_name
        self.age = age
        self.roll_number = roll_call

    def student_info(self):
        self.university_info()
        self.college_info()
        print(f"Student Name: {self.student_name}")
        print(f"Age: {self.age}")
        print(f"Roll Call: {self.roll_number}")

s1 = Student("XYZ University", "California", "Computer Science", "Megha", 20, "CSC123")
s1.student_info()

"""##### ***Write a multilevel inheritance example with a class A having a method greet(), B(A) adding introduce(), and C(B) adding describe(). Call all three methods from an object of class C.***

# **Steps Breakdown**

> *Class A has a method greet().*

> *Class B inherits from A and adds introduce() method.*

> *Class C inherits from B and adds describe() method.*

> *Finally, we create an object of class C and call all three methods.*
"""

class A:
    def greet(self):
        print("Hello I am class A")

class B(A):
    def introduce(self):
        print("Hey, I am Class B")

class C(B):
    def describe(self):
        print("Hi, I am Class C")

# Create an object
c1 = C()

# Calling methods from class A,B,C
c1.greet()
c1.introduce()
c1.describe()